Установка:

Необходимое ПО:

1. Eclipse
2. Eclipse ADT plugin
3. Android SDK

Первоначально нужно установить средства разработки Android. Первое - SDK,
скачиваеться с сайта http://developer.android.com/sdk/index.html под свою платформу (Windows 32bit).
Нужно внизу страницы выбрать Download for other platforms, там SDK tools only.
Распаковываеться в доступное место, например c://android-sdk

Далее необходимо проверить что внутри есть папка platform-tools, если нет, 
то из консоли набрать команду .../android-sdk/tools/android.exe update sdk -u и ждем окончания обновления.

Далее устанавливаеться Eclipse ADT plugin. Для этого в Eclipse заходим:

Help - Install New Software. Добавляем репозиторий: нажимаем кнопку Add,
в поле Name пишем ADT plugin, в поле location пишем адрес https://dl-ssl.google.com/android/eclipse/ Нажимаем ОК.

Список должен обновиться и появятся пункт Developer tools. Выбираем его галочкой и 
нажимаем Next. Соглашаемся со всеми условиями и так до тех пор пока Eclipse 
не захочем перезапуститься. Перезапускаем.

После перезапуска попросят ввести параметры Android SDK. Пишем путь к вышескачанному SDK:
C:/android-sdk. Установка плагина закончена.

Далее устанавливаем необходимые библиотеки Android API, для этого заходим в 
Window - Android SDK manager.

В открывшемся окне проверям что компоненты Android SDK tools и Android SDK platform-tools установлены 
и ищем Android 2.2 (API 8). Там ставим галочку напротив SDK platform и жмем ниже
Install 1 package. Кликаем Next и ждем конца скачивания и установки.

Далее важная часть насчет подключения телефона. Впринципе можно программу запустить 
и в эмуляторе, но лучше на устройстве. Устанавливаем драйвер телефона (для HTC это программа HTC Sync) 
Важно телефон подключать в режиме отладки к компьютеру.

Захолдим в папку с Android SDK, в папку platform-tools. Там есть утилита adb. Пишем adb.exe devices
Если она выдала что-нибудь кроме пустоты, то значит драйвер установился правильно и можно продолжать работу.

Настройка проектов:

проект android-local-chat-project - это Android приложение.Импортируем его в Eclipse:

File - Import - Android - Existing Android Code... Выбираем путь к проекту и жмем ОК.

Теоретически проект сразу должен заработать и никаких красных крестиков быть не должно.

Запустить: подключить телефон, проверить что adb его видит. Правой кнопкой на проект - Run As - Android Application. 
Нужно выбрать устройства и нажать ОК. Приложение должно запуститься на телефоне.

Важный пункт - скопировать файл configuration.xml из корня репозитория в корень SD-карты телефона.

Проект android-local-chat-project-server - серверная часть системы. Представляет собой просто java приложение. 
Необходимо экспортировать его в Eclipse. А также указать где лежат 2 необходимые ему библиотеки:

sqlite-jdbc-3.7.2.jar и javadoc. Они лежат по дефолту в корне репозитория. 
Правой кнопкой на проект - Build Path - Configure Build. Во вкладке Libraries указать где лежат библиотеки (Add external JAR)
Также нужно в файле dbConnectionHandler.java поменять на строке 20 абсолючтный путь к файлу БД: dbfile.db на свой. Он лежит в корне проекта.

После этих дейцствий ошибок в проекте быть не должно и он должен запуститься.

Как заставить это все работать вместе:

Необходимо чтобы компьютер с сервером были в одной подсети с телефоном. Можно либо обоих их подключить к одному роутеру либо
поднять на телефоне точку доступа Wifi и подключиться к нем компьютером.

После того как они в одной сети, нужно посмотреть IP адрес компьютера с сервером. Запомнить его.
в файле configuration.xml на телефоне обязательно должно быть:

-Указан правильный адрес сервера: параметр server_ip, к примеру 192.168.0.101
-Указаны правильные параметры шифоования (иногда любят сбиваться) - параметры desiv и deskey:

<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<Configuration><section name="UIConfiguration" desc="">
<param key="desiv" value="93842901" /> - должно быть так
<param key="server_ip" value="192.168.43.163" /> --- должен быть правильный адрес
<param key="username" value="user" />  --- юзернейм.
<param key="deskey" value="02345780185" /> - должно быть так
</section>
</Configuration>

Проверить правильность подгрузки конфигурации легко - если в приложении внизу отобразиться правильное имя юзера
то все нормально.

Итак, теперь необходимо запустить сервер на компьютере. Если все нормально, то он должен выдать что-то такое:

[ServerMainWindow][info]Starting server..
193.125.22.1
[ChatServer][info]Waiting for new message..
[ServerMainWindow][info]Server started successfully.

Далее запустить приложение на телефоне, нажать меню и выбрать пункт Register. Если все пройдет хорошо,
то значок внизу экрана должен стать зеленым. Если это так, то можно радоваться - все было настроено правильно. Можно пользоваться.


Описание архитектуры мобильного приложения:

В самом низу лежит UDP клиент, который умеет посылать и принимать сообщения с сервера по сконфигурированному IP адресу.
Он описан в файле ChatClient.java
Сообщения передаются в зашифрованном виде (протокол шифрования DES). Тоесть сообщения шифруются на одной стороне с использованием ключа
и дешифруются на другой стороне с использованием такого же ключа. Ключи на сервере и на клиенте соответственно должны быть одинаковы
(Ключ на клинте прописывается в конф. файле) (На сервере захардкожен).

На все отправленные сообщения должны приходить ответы подтверждения принятия сообщения
(неважно кто отправил сообщение, клиент или сервер). Сделано для лучшей стабильность. Например клиент не зайдет
в разговорную группу пока сервер не пришлет положитлеьный ответ на его запрос на вступление.

После дешифрации сообщение передаеться выше на уровень и попадает в контроллер, где в зависимости от содержимого
делаються нужные действия (сообщение выводиться пользователю, обновляеться статус чего либо или другие технические действия)

В клиенте используются State машины. Тоесть клиент всегда находиться в каком либо состоянии и готов его изменить по проишествию
какого либо евента. Стейт машины описаны в файлах FSMSTATES и FSMEVENTS. В клиенте заранее прописаны действия, которые необходимо выполнять
при проишествии определенного евента и т.д. ТАкже такая система помогает следить за ошибками (стейт машина может передвигаться
только по заранее определенным маршрутам, в случае попытки вызвать неверный маршрут будет сообщение об ошибке)
Так если вызвать меню Register если ты уже зарегистрирован, ничего не получится, потому что в стейт машине нет пути из состояния Registered - Registered.

Так, есть состояния:

public final static int Null_state = 0; - изначальное состояние
    public final static int Sending_Register = 1; - посылка сообщения регистрации. Клиент находиться в нем когда нажали
    кнопку Register
    public final static int Sending_Deregister = 2; - аналогично дерегистрация
    public final static int Registered = 3; - Клиент зарегистрирован в сети
    public final static int Sending_Join = 4; - посылка запроса на вступление в группу
    public final static int InTalkGroup = 5; - в группе
    public final static int Sending_Bye = 6; - посылка запроса на покидание группы
    public final static int NotInGroup = 7;
    
    Евенты могут быть:
public final static int Register = 1; - был послан запрос на регистрацию
    public final static int Register_success = 2; - регистрация удалась
    public final static int Register_Failed = 3;
    public final static int Join = 4; - был послан запрос на вступление в группу
    public final static int Join_Success = 5;
    public final static int Join_Failed = 6;
    public final static int Bye = 7;
    public final static int Deregister = 8;
    public final static int Deregister_Success = 9;
    public final static int Deregister_Failed = 10;
    public final static int Init = 11;
    public final static int Bye_Success = 12;
    public final static int Bye_Failed = 13;
    
    
Возможные переходы и действия которые им соответствуют описаны в ChatController в методе InitStateMachines(), например

 this.Initiate_Fsm.addTransitionState(FSMSTATES.Null_state, FSMSTATES.Sending_Register, new FiniteStateMachineListener() {
			public void eventMethod(int event) { Register(); }}, FSMEVENTS.Register);
			
			Означает что находясь в состоянии Null_state и получении сигнала Register будет выполнена функция Register() 
			и клиент будет переведен в состояние Sending_Register.
			
Из фич стоит выделить ту, что приложение постоянно мониторит состояние сети и при потере связи юзер будет уведомлен об этом
и приложение автоматически вернется в изначальное состояние, что не даст пользователю шансов что-нибудь сломать. Мониторится
это использованием Android API к Wifi устройству.

Также на некоторые стандартные хардверные кнопки (например кнопку Back) повешены дополнительные функции.
Например при нажатии на Back при нахождении в группе бна сервер удет автоматически послан запрос на уход 
из группы. Или же при нажатии на Back находясь на главном экране будет выведено уведомление, действительно ли 
пользователь хочет выйти из приложения, если да, то нажмите Back еще раз. Это позволяет корректно обрабатывать событие 
закрытия приложения (посылать на сервер уведомление, что клиент закрываеться). Сервер в свою очередь сообщит всем остальным
клиентам, что пользователь теперь Offline.

Немного про UI:

Содержимое и поведение экрана в Android управляеться сущность под названием Activity. Приложение может иметь несколько 
Activity с разным содержимым. Например главный экран управляеться классом MainActivity, экран приватного разговора - PrivateTalkActivity и т.д.
Для каждого активити нужно задать настройка расположения элементов на нем - файл layout'a. Эти файлы находяться в папке res/layout проекта.

В MainActivity есть строки:

protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		this.requestWindowFeature(Window.FEATURE_NO_TITLE);
		setContentView(R.layout.activity_main);
		
Они означают что при создании экрана: первое - у него не будет верхнего заголовка с названием, второе - что для оформления экрана 
будет использоваться файл разметки activity_main. R.layout.activity_main неявно указывает на файл /res/layout/activity_main.xml.

В этом файле указано как компоновать элементы, например кнопки и текстовые поля.

Вообще есть визуальный редактор (увидишь если нажмешь на файл activity_main.xml, но лучше редактировать вручную)
Например строки 
<TextView
		        android:id="@+id/userName"
		        android:layout_width="wrap_content"
		        android:layout_height="fill_parent"
		        android:layout_gravity="bottom"
		        android:layout_marginTop="3dp"
		        android:textSize="15dp"
		        android:text="username" 
		        android:textColor="#ffffff"/> 
определяют текстовый label. 
У каждого элемента есть свой ID, по которому из класса Activity можно управлять элементом. Например в MainActivity:

this.userNameTxt = (TextView)findViewById(R.id.userName);

получает управляющий элемент текстового лейбела с именем пользователя внизу экрана. Затем через этот объект можно управлять
его содержимым (например устанавливать или получать оттуда текст).

Обработка нажатия на кнопки делаеться стандартным способом, с помощью Listener'ов, например:
Устаналивает обработчик на нажатие иконки юзера:
this.userStatusImg.setOnClickListener(new OnClickListener(){
			public void onClick(View arg0) {
			//необходимые действия
			
Серверное приложение:

Принимает UDP сообщения, обрабатывает их и выполняет нужные действия. Например принимает запросы регистрации пользователей, 
запоминает всех существующих пользователей. 
Вообще выполняет роль пересыльщика всевозможных сообщений. UseCase:

Юзер заходит в сеть, регистрируеться. Сервер принимает запрос на регистрацию и одновременно с отсылкой ответа пользователю
уведомляют всех других юзеров в системе, что определенный клиент вошел в систему. У остальных клиентов в списке контактов появляеться 
новое имя.
